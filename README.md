# 20223127_open_source


---
### LINUX COMMAND (top, ps, jobs, kill)
---


# top

' top ' 명렁어는 리눅스 시스템에서 실행 중인 프로세스와 시스템의 자원 사용 현환을 실시간으로 보여주는 강력한 유틸리티입니다.
## 사용법
기본적으로 터미널 환경에서 ' top ' 명령어를 입력하고 엔터를 누르면 실행됩니다.
## 주요기능 
+ 실시간 모니터링: ' top ' 명령어는 일정 주기로 화면을 업데이트하여 시스템 성능을 실시간으로 모니터링 할 수 있습니다.
+ 프로세스 정보: 실행 중인 프로세스의 PID(프로세스 ID), 사용자, 우선 순위, 메모리 사용량, CPU 사용량 등을 보여줍니다.
+ 시스템 요약:  화면 상단에 시스템의 전반적인 성능 지표를 요약하여 표시합니다. 이는 시스템 가동 시간, 사용자 수, 로드 평균, CPU 상태, 메모리 사용량, 스왑 공간 사용량 등을 포함합니다.
## 주요 옵션
| 옵션 | 설명 |
| :---: | :---: |
| -d | 지정한 시간(delay) 간격으로 정보를 출력 |
| -n | 지정한 횟수(num)만큼 정보를 출력 |
| -p | 지정한 프로세스 id(pid)의 정보만 출력 |

## 사용화면 및 요소 설명
![image](<./top 명령어.png>)
## 첫 번째 줄

- 현재 시간: 
12:52:38
- 서버 가동 후 유지시간: _up 17:25 min_
- 현재 접속자 수: __0 user__
- 평균 부하(1분, 5분, 15분): ***load average(0.16, 0.03, 0.01)***

## 두 번째 줄
+ 프로세스 상태 (전체, 실행중, 유후, 정지, 좀비)

## 세 번째 줄
* cpu 상태

## 네 번째 줄
* 메모리 상태

## 다섯 번째 줄
* swap 메모리 상태

## 여섯 번째 줄 
* PID: 프로세스 ID
* USER: 소유자
- PR: 우선순위
- NI: nice 우선순위
+ VIRT: 가상메모리 사용량
+ RES: 실제 물리메모리 사용량
- SHR: 공유 메모리 사용량
- S: 프로세스 상태

  ## ps

'ps' (process status) 명령어는 현재 실행 중인 프로세스의 상태를 스냅샷(Snapshot)처럼 찍어서 보여주는 명령어입니다. `top`과 달리 실시간이 아니라 명령어를 입력한 **그 순간**의 상태를 출력합니다.

## 사용법
터미널에서 `ps`를 입력하거나, 다양한 옵션을 조합하여 `ps -ef`, `ps aux` 형태로 사용합니다.

## 주요기능
+ **프로세스 확인**: 현재 쉘에서 실행된 프로세스뿐만 아니라 시스템 전체의 프로세스 목록을 확인할 수 있습니다.
+ **상세 정보 조회**: 프로세스의 소유자(UID), PID, 부모 프로세스(PPID), 시작 시간 등을 상세히 볼 수 있습니다.
+ **특정 프로세스 검색**: `grep` 명령어와 조합하여 특정 프로세스가 떠 있는지 확인할 때 자주 사용됩니다. (예: `ps -ef | grep tomcat`)

## 주요 옵션
| 옵션 | 설명 |
| :---: | :---: |
| `-e` | 모든 프로세스를 출력 (Every) |
| `-f` | 풀 포맷(Full format)으로 상세 정보를 출력 (UID, PID, PPID 등 표시) |
| `-a` | 다른 터미널의 프로세스까지 모두 출력 (All) |
| `-u` | 프로세스 소유자의 이름과 시작 시간 등을 출력 (User) |
| `aux` | (BSD 문법) 시스템의 모든 프로세스를 소유자 정보와 함께 출력 |

## 사용화면 및 요소 설명
![ps 명령어 실행 화면](./ps_command.png)

### 출력 필드 설명 (ps -ef 기준)
- **UID**: 프로세스 소유자의 ID
- **PID**: 프로세스 ID (Process ID)
- **PPID**: 부모 프로세스 ID (Parent Process ID)
- **C**: CPU 사용량 (정수형)
- **STIME**: 프로세스 시작 시간 (Start Time)
- **TTY**: 프로세스가 연결된 터미널 포트
- **TIME**: 총 CPU 사용 시간
- **CMD**: 실행된 명령어 (Command)

---

# jobs

'jobs' 명령어는 백그라운드(Background)에서 실행 중이거나 중지된 프로세스(작업)의 목록을 보여주는 쉘 내부 명령어입니다.

## 사용법
터미널에서 `jobs`를 입력하면 현재 쉘 세션의 작업 목록이 출력됩니다.

## 주요기능
+ **백그라운드 작업 관리**: 터미널 하나에서 여러 작업을 동시에 돌릴 때, 뒤에서 돌고 있는 작업들을 확인할 수 있습니다.
+ **작업 상태 확인**: 작업이 실행 중(Running)인지, 정지됨(Stopped)인지, 종료됨(Done)인지 상태를 보여줍니다.
+ **작업 제어**: 작업 번호를 확인한 후 `fg`(포그라운드로 가져오기)나 `bg`(백그라운드로 보내기) 명령어로 제어할 수 있습니다.

## 주요 옵션
| 옵션 | 설명 |
| :---: | :---: |
| `-l` | 프로세스 ID (PID)를 함께 출력 |
| `-p` | 프로세스 그룹 리더의 PID만 출력 |
| `-r` | 실행 중인(Running) 작업만 출력 |
| `-s` | 정지된(Stopped) 작업만 출력 |

## 사용화면 및 요소 설명
![jobs 명령어 실행 화면](./jobs_command.png)

### 출력 필드 설명
- **[번호]**: 작업 번호 (Job ID). `kill`이나 `fg` 명령어를 쓸 때 `%번호`로 사용합니다.
- **+ (Plus)**: 가장 최근에 접근한 작업 (current)
- **- (Minus)**: 두 번째로 최근에 접근한 작업 (previous)
- **Running / Stopped**: 작업의 현재 상태
- **명령어**: 실행된 명령어의 내용

---

# kill

'kill' 명령어는 특정 프로세스나 작업에 **시그널(Signal)**을 보내어 프로세스를 종료시키거나 제어하는 명령어입니다.

## 사용법
종료하려는 프로세스의 **PID**나 **작업 번호**를 확인한 후 `kill [옵션] PID` 형태로 입력합니다.

## 주요기능
+ **프로세스 종료**: 응답이 없거나 불필요한 프로세스를 강제로 종료시킬 수 있습니다.
+ **시그널 전송**: 단순히 죽이는 것뿐만 아니라, 프로세스를 잠시 멈추거나 재시작하는 등 다양한 신호를 보낼 수 있습니다.
+ **안전한 종료**: 기본적으로 종료 신호(TERM)를 보내 프로세스가 스스로 정리하고 꺼지도록 유도합니다.

## 주요 옵션
| 옵션 | 설명 |
| :---: | :---: |
| `-l` | 사용할 수 있는 모든 시그널의 종류를 나열 |
| `-15` (SIGTERM) | [기본값] 정상 종료 시그널. 프로세스가 정리할 시간을 줌 |
| `-9` (SIGKILL) | 강제 종료 시그널. 프로세스를 즉시 죽임 (데이터 손실 위험 있음) |
| `-2` (SIGINT) | 키보드로 `Ctrl+C`를 누른 것과 같은 인터럽트 시그널 전송 |

## 사용화면 및 요소 설명
![kill 명령어 실행 화면](./kill_command.png)

### 시그널 번호 설명
리눅스에서는 프로세스 종료 시 주로 아래 두 가지를 사용합니다.
- **kill -15 [PID]**: "이제 그만 종료해 줄래?" 하고 정중하게 요청합니다. (권장)
- **kill -9 [PID]**: "묻지도 따지지도 말고 당장 사라져!" 하고 강제로 삭제합니다. (최후의 수단)


